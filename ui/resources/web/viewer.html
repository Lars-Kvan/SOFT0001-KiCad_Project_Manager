<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Viewer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #ffffff;
    }
    #viewer {
      width: 100%;
      height: 100%;
      position: relative;
    }
    #overlay {
      position: absolute;
      top: 8px;
      left: 10px;
      color: #1f2937;
      font: 12px/1.4 "Segoe UI", sans-serif;
      background: rgba(255,255,255,0.85);
      border: 1px solid #d0d7de;
      border-radius: 6px;
      padding: 4px 8px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="viewer">
    <div id="overlay"></div>
  </div>
  <script>
    window.__viewerReady = false;
  </script>
  <script src="./three.legacy.min.js"></script>
  <script src="./OrbitControls.legacy.js"></script>
  <script src="./GLTFLoader.legacy.js"></script>
  <script src="./STLLoader.legacy.js"></script>
  <script src="./OBJLoader.legacy.js"></script>
  <script src="./PLYLoader.legacy.js"></script>
  <script>

    let scene, camera, renderer, controls;
    let currentObject = null;
    const overlay = document.getElementById('overlay');
    const container = document.getElementById('viewer');

    function setOverlay(text) {
      overlay.textContent = text || '';
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.001, 10000);
      camera.position.set(40, -40, 40);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 1.0));
      const hemi = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
      hemi.position.set(0, 1, 0);
      scene.add(hemi);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enablePan = false;
      controls.rotateSpeed = 0.6;

      window.addEventListener('resize', onResize);
      onResize();
      animate();
    }

    function onResize() {
      if (!renderer || !camera) {
        return;
      }
      const width = container.clientWidth || 1;
      const height = container.clientHeight || 1;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (controls) {
        controls.update();
      }
      if (renderer && scene && camera) {
        renderer.render(scene, camera);
      }
    }

    function clearScene() {
      if (currentObject) {
        scene.remove(currentObject);
        currentObject.traverse((child) => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach((m) => m.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
        currentObject = null;
      }
    }

    function forceBrightMaterials(object) {
      object.traverse((child) => {
        if (child && child.isMesh) {
          const color = (child.material && child.material.color) ? child.material.color.clone() : new THREE.Color(0x8aa4c8);
          const balanced = color.clone();
          balanced.r = 0.12 + 0.58 * balanced.r;
          balanced.g = 0.12 + 0.58 * balanced.g;
          balanced.b = 0.12 + 0.58 * balanced.b;
          child.material = new THREE.MeshStandardMaterial({
            color: balanced,
            metalness: 0.0,
            roughness: 0.9,
            emissive: balanced.clone().multiplyScalar(0.03),
          });
        }
      });
    }

    function fitToObject(obj) {
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      if (!isFinite(maxDim) || maxDim <= 0) {
        return;
      }
      const distance = maxDim * 2.2;
      camera.near = Math.max(distance / 1000, 0.0001);
      camera.far = Math.max(distance * 100, 1000);
      camera.updateProjectionMatrix();
      const iso = new THREE.Vector3(-1, 1, 1).normalize().multiplyScalar(distance);
      camera.up.set(0, 0, 1);
      camera.position.set(center.x + iso.x, center.y + iso.y, center.z + iso.z);
      camera.lookAt(center);
      if (controls) {
        controls.target.copy(center);
        controls.update();
      }
    }

    function addAndFit(object) {
      clearScene();
      currentObject = object;
      forceBrightMaterials(currentObject);
      scene.add(currentObject);
      fitToObject(currentObject);
      setOverlay('');
      window.__lastLoadOk = true;
    }

    function loadGLTF(url) {
      const loader = new THREE.GLTFLoader();
      loader.load(url, (gltf) => {
        addAndFit(gltf.scene);
      }, undefined, (err) => {
        setOverlay('3D preview failed to load');
        console.error(err);
      });
    }

    function loadSTL(url) {
      const loader = new THREE.STLLoader();
      loader.load(url, (geometry) => {
        const material = new THREE.MeshStandardMaterial({ color: 0x4b6b88, metalness: 0.05, roughness: 0.5 });
        const mesh = new THREE.Mesh(geometry, material);
        addAndFit(mesh);
      }, undefined, (err) => {
        setOverlay('3D preview failed to load');
        console.error(err);
      });
    }

    function loadOBJ(url) {
      const loader = new THREE.OBJLoader();
      loader.load(url, (obj) => {
        obj.traverse((child) => {
          if (child.isMesh) {
            child.material = new THREE.MeshStandardMaterial({ color: 0x4b6b88, metalness: 0.05, roughness: 0.5 });
          }
        });
        addAndFit(obj);
      }, undefined, (err) => {
        setOverlay('3D preview failed to load');
        console.error(err);
      });
    }

    function loadPLY(url) {
      const loader = new THREE.PLYLoader();
      loader.load(url, (geometry) => {
        geometry.computeVertexNormals();
        const material = new THREE.MeshStandardMaterial({ color: 0x4b6b88, metalness: 0.05, roughness: 0.5 });
        const mesh = new THREE.Mesh(geometry, material);
        addAndFit(mesh);
      }, undefined, (err) => {
        setOverlay('3D preview failed to load');
        console.error(err);
      });
    }

    window.loadModel = function (url) {
      if (!url) {
        setOverlay('3D model not available');
        clearScene();
        window.__lastLoadOk = false;
        return;
      }
      setOverlay('Loading 3D model...');
      window.__lastLoadOk = false;
      const lower = url.toLowerCase();
      if (lower.endsWith('.gltf') || lower.endsWith('.glb')) {
        loadGLTF(url);
      } else if (lower.endsWith('.stl')) {
        loadSTL(url);
      } else if (lower.endsWith('.obj')) {
        loadOBJ(url);
      } else if (lower.endsWith('.ply')) {
        loadPLY(url);
      } else {
        setOverlay('Unsupported 3D format');
        window.__lastLoadOk = false;
      }
    };

    window.rotateView = function (dx, dy) {
      if (!camera || !controls) return;
      const radX = THREE.MathUtils.degToRad(dx || 0);
      const radY = THREE.MathUtils.degToRad(dy || 0);
      const offset = new THREE.Vector3();
      offset.copy(camera.position).sub(controls.target);
      const spherical = new THREE.Spherical();
      spherical.setFromVector3(offset);
      spherical.theta += radX;
      spherical.phi = Math.max(0.01, Math.min(Math.PI - 0.01, spherical.phi + radY));
      offset.setFromSpherical(spherical);
      camera.position.copy(controls.target).add(offset);
      camera.lookAt(controls.target);
      controls.update();
    };

    window.resetView = function () {
      if (!currentObject) return;
      fitToObject(currentObject);
    };

    init();
    window.__viewerReady = true;
  </script>
</body>
</html>
